subsystem = IRIS
component = oiwfs.detector

description = "OIWFS Detector Assembly Commands."

receive = [
    {
        name            = debug
        description     = """Change the assembly debug message level. (engineering)

    The assembly will log all messages that correspond to the current debug message level as well as all lower levels (e.g. if the current debug message level is INFO, then all INFO, WARN and ERROR messages will be logged). Below are the debug message levels in descending order.
    <ul>
    <li>    \b DEBUG: extra details as messages are processed
    <li>    \b INFO : connections and command status
    <li>    \b WARN(ing) : unexpected events/messages/etc
    <li>    \b ERROR: failed to do something
    </ul>

    *Friendly Command.*

    Precondition:
    <ul>
    <li> state.cmd != UNINITIALIZED
    </ul>
    Execution:
    <ul>
    <li> none
    </ul>
    At Completion:
    <ul>
    <li> state.debug = {input debug}
    </ul>"""
        args = [
            {
                name        = debug
                description = target debug level
                enum        = [ DEBUG, INFO, WARN, ERROR ]
            }
        ]
        requiredArgs = [ debug ]
   }


{
    name            = init
    description     = """Prepares the assembly for operation and reads configuration files. (engineering)

This command initializes the assembly and also (re-)establishes connections with the OIWFS Detector HCDs. It does not trigger a reinitialization of the OIWFS detectors themselves.

This command will internally trigger an exposure command with the mode set to STOP if needed.

If configName and configVersion are not specified in the input, then the default configuration name and version will be used. If only configName is specified in the input, then the default version for the specified configName will be used. If only configVersion is specified in the input, then an error is returned.

*Discrete Command.*

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
    args = [
       {
        name        = configName
        description = Name of the configuration file to get from the TMT Configuration Service
        type        = string
      }
      {
        name        = configVersion
        description = Version of the configuration file to get from the TMT Configuration Service
        type        = string
      }
    ]
  }

{
    name            = init_detector
    description     = """Initialize and configures the OIWFS detectors. (engineering)

The purpose of this command is to instruct the OIWFS Detector HCDs to trigger detector (re-)initialization, which includes establishing a connection to the camera hardware, and configuring the detector controller. This is potentially a slow operation (e.g., 1 s), and may cause detector transients. It should normally only be performed once when the cameras are first energized.

This command will internally trigger an exposure command with the mode set to STOP if needed.

*Discrete Command.*

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
    args = [
       {
        name        = whichDetector
        description = Indicate which detectors are to be (re-)initialized
        type = array
        dimensions: [3]
        items = {
            type = boolean
        }
       }
    ]
  }

{
        name = config
        description     = """Reads configuration files. (engineering)

If configName and configVersion are not specified in the input, then the default configuration name and version will be used. If only configName is specified in the input, then the default version for the specified configName will be used. If only configVersion is specified in the input, then an error is returned.

This command does not otherwise alter the state of the assembly (i.e., unlike init, this command will not reset internal state variables).

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
<li> state.move = false
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> config.posTolerance
<li> config.transDisp_Filename
<li> config.transMotor_Filename
<li> config.imageShift_Filename
<li> config.defaultOrientation
<li> config.defaultPower
</ul>
"""
        args = [
            {
                name        = configName
                description = "Name of the configuration file to get from the TMT Configuration Service"
                type        = string
            }
            {
                name        = configVersion
                description = "Version of the configuration file to get from the TMT Configuration Service"
                type        = string
            }
        ]
   }



    {
        name = exposure
        description = """Set the exposure mode for the OIWFS

This command will perform the following actions depending on the selected mode for each of the three OIWFS detectors: SINGLE (initiate a single exposure), CONTINUOUS (continuously take exposures as triggered by NFIRAOS trigger signal and simultaneously step through the guide and acquisition table), STOP (stop exposure), or NOOP (leave exposure mode unchanged). SINGLE exposures are intended to generate test and calibration data. When SINGLE is specified, the other arguments must also be provided: filenames for each detector exposure (including either a '_flat' or '_dark' suffix if being used to generate calibration data), as well as the total integration time for the exposure.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY | CONTINUOUS
</ul>

"""
        requiredArgs = [mode]
        args = [
            {
                name = mode
                description = """
<ul>
<li> <b>SINGLE</b>: Initiate a single exposure (must specify remaining attributes)
<li> <b>CONTINUOUS</b>: continuously take exposures as instructed by NFIRAOS using the fast connection.
<li> <b>STOP</b>: Stop single exposure and/or continous following.
<li> <b>NOOP</b>: Leave OIWFS mode unchanged.
</ul>
"""
                type = array
                dimensions: [3]
                items = {
                      enum = [SINGLE, CONTINUOUS, STOP, NOOP]
                }
            }
            {
                name = filenames
                description = "Specify file names if SINGLE mode"
                type = array
                dimensions: [3]
                items = {
                      type = string
                }
            }
            {
                name = integration
                description = "Specify integration times if SINGLE mode"
                type = array
                dimensions: [3]
                items = {
                      type = double
                }
            }
        ]
    }

    {
        name = cal_config
        description = """Specify names of calibration files required to process exposures taken with each OIWFS detector.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY | CONTINUOUS
</ul>

"""
        args = [
            {
                name = flats
                description = "Flatfield filenames for each detector"
                type = array
                dimensions: [3]
                items = {
                      type = string
                }
            }
            {
                name = darks
                description = "Dark filenames for each detector"
                type = array
                dimensions: [3]
                items = {
                      type = string
                }
            }
        ]
    }

    {
        name = init_acquisition_table
        description = """Set the current OIWFS guide/acquisition table for each detector.

Each guide/acquisition table is supplied as a string, one for each detector. If the active flag is set to OFF no table will be used.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY | CONTINUOUS
</ul>

"""
        args = [
            {
                name = active
                description = "Indicate whether each table is in use or not"
                type = array
                dimensions: [3]
                items = {
                      type = boolean
                }
            }
            {
                name = table
                description = "Table for each detector, encoded as strings"
                type = array
                dimensions: [3]
                items = {
                      type = string
                }
            }

        ]
    }

    {
        name = table_jump
        description = """Jump to the specified rows of each OIWFS detector guide/acquisition table

The command fails if the detectors are not in CONTINUOUS exposure mode.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY | CONTINUOUS
</ul>

"""
        args = [
            {
                name = row
                description = "Row to jump to in each table. If -1, continue at current row"
                type = array
                dimensions: [3]
                items = {
                      type = integer
                }
            }

        ]
    }

    {
        name = tracking_override
        description = """Override the tracking/following behaviour for testing purposes. (engineering)

This command is used to override the default tracking and following behaviours that are normally established by monitoring events published by the OIWFS POA Assembly, TCS, and NRTC, for testing purposes.

Only the required attributes need be set. For example, an initial invocation with probePosOverride can be used to specify which probes will have position overrides. Subsequent invocations specifying only the probePos attributes can then be used to move the simulated probe around.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>

"""
        args = [
            {
                name          = trackingType
                description   = "type for each of the three probes. DISABLE is used to deactivate the override"
                type          = array
                dimensions: [3]
                items = {
                    enum = [ TRACK_POA, TRACK_ON_CHIP, DITHER_POA, DITHER_ON_CHIP, DISABLE ]
                }
            }
            {
                name = tcsFollow
                description = "Indicate if following TCS for each probe"
                type = array
                dimensions: [3]
                items = {
                    enum = [ ON, OFF, DISABLE ]
                }
            }
            {
                name = rtcOffset
                description = "Indicate if following RTC offsets for each probe"
                type = array
                dimensions: [3]
                items = {
                    enum = [ ON, OFF , DISABLE]
                }
            }
            {
                name = probePosOverride
                description = "Indicate which probe positions are being overriden"
                type = array
                dimensions: [3]
                items = {
                      type = boolean
                }
            }
            {
                name = probePos
                description = "Probe positions to use if being overriden, in FCRS<sub>IRIS-ROT</sub>"
                type = array
                dimensions: [3,2]
                units = mm
                items = {
                      type = double
                }
            }
            {
                name = staticOffsetOverride
                description = "Indicate which probe static offsets are being overriden"
                type = array
                dimensions: [3]
                items = {
                      type = boolean
                }
            }
            {
                name = staticOffset
                description = "Static offsets to use if being overriden, in FCRS<sub>IRIS-ROT</sub>"
                type = array
                dimensions: [3,2]
                units = mm
                items = {
                      type = double
                }
            }
            {
                name = rtcOffsetOverride
                description = "Indicate which NRTC offsets are being overriden"
                type = array
                dimensions: [3]
                items = {
                      type = boolean
                }
            }
            {
                name = rtcOffset
                description = "NRTC offsets to use if being overriden, in FCRS<sub>IRIS-ROT</sub>"
                type = array
                dimensions: [3,2]
                units = mm
                items = {
                      type = double
                }
            }
        ]
    }
]
